<!DOCTYPE html>
<html lang="et">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solaris - Redaktor</title>
    <script src="../translations/i18n.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #4a9eff;
            margin-bottom: 10px;
        }
        
        .header a {
            color: #4a9eff;
            text-decoration: none;
            font-size: 0.9em;
        }
        
        .header a:hover {
            text-decoration: underline;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .section {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .section h2 {
            color: #4a9eff;
            margin-bottom: 20px;
            border-bottom: 2px solid #3a3a3a;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }
        
        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 1em;
            font-family: inherit;
        }
        
        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-inline {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            .form-inline {
                grid-template-columns: 1fr;
            }
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 30px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            background: #3a8eef;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 158, 255, 0.4);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        button.secondary {
            background: #555;
        }
        
        button.secondary:hover:not(:disabled) {
            background: #666;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .status.success {
            background: #2d5016;
            border: 1px solid #4a8c2a;
            color: #90ee90;
        }
        
        .status.error {
            background: #5a1616;
            border: 1px solid #8a2a2a;
            color: #ff8a8a;
        }
        
        .status.info {
            background: #1a3a5a;
            border: 1px solid #2a5a8a;
            color: #8ac8ff;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        thead {
            background: #3a3a3a;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #4a4a4a;
        }
        
        th {
            color: #4a9eff;
            font-weight: 600;
        }
        
        tbody tr:hover {
            background: #333;
        }
        
        .play-btn {
            padding: 6px 12px;
            font-size: 0.85em;
        }
        
        .table-wrapper {
            overflow-x: auto;
        }
        
        .hidden {
            display: none;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow: auto;
        }
        
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #3a3a3a;
            padding-bottom: 10px;
        }
        
        .modal-header h3 {
            color: #4a9eff;
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            color: #fff;
        }
        
        .delete-btn {
            padding: 6px 12px;
            font-size: 0.85em;
            background: #d32f2f;
        }
        
        .delete-btn:hover:not(:disabled) {
            background: #b71c1c;
        }
        
        .edit-btn {
            padding: 6px 12px;
            font-size: 0.85em;
            background: #f57c00;
        }
        
        .edit-btn:hover:not(:disabled) {
            background: #e65100;
        }
        
        th.sortable {
            cursor: pointer;
            user-select: none;
        }
        
        th.sortable:hover {
            background: #4a4a4a;
        }
        
        th.sortable::after {
            content: ' ⇅';
            opacity: 0.5;
        }
        
        th.sortable.sorted-asc::after {
            content: ' ▲';
            opacity: 1;
        }
        
        th.sortable.sorted-desc::after {
            content: ' ▼';
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 data-i18n="editor.title">Solaris - Editor</h1>
            <a href="../index.html" data-i18n="common.backToMenu">← Back to Main Menu</a>
        </div>
        
        <!-- New Command Section -->
        <section class="section">
            <h2 data-i18n="editor.newCommand">New Command</h2>
            <form id="commandForm">
                <div class="form-group">
                    <label for="commandText" data-i18n="editor.commandText">Command Text:</label>
                    <textarea id="commandText" data-i18n-placeholder="editor.commandTextPlaceholder" placeholder="Enter the text to convert to speech..." required></textarea>
                </div>
                
                <div class="form-group">
                    <label for="commandName" data-i18n="editor.commandName">Command Name (no spaces):</label>
                    <input type="text" id="commandName" data-i18n-placeholder="editor.commandNamePlaceholder" placeholder="e.g., greeting001" required pattern="[^\s]+">
                </div>
                
                <div class="button-group">
                    <button type="submit" id="sendBtn" data-i18n="editor.generateAudio">Generate Audio</button>
                    <button type="button" id="listenBtn" class="secondary" disabled data-i18n="editor.listen">Listen</button>
                </div>
                
                <div id="commandStatus" class="status hidden"></div>
            </form>
        </section>
        
        <!-- Commands Table Section -->
        <section class="section">
            <h2 data-i18n="editor.commands">Commands</h2>
            <button type="button" id="refreshCommandsBtn" class="secondary" data-i18n="editor.refreshCommands">Refresh Commands</button>
            <div id="commandsStatus" class="status hidden"></div>
            <div class="table-wrapper">
                <table id="commandsTable">
                    <thead>
                        <tr>
                            <th data-i18n="editor.commandName_table">Command Name</th>
                            <th data-i18n="editor.fileName">File Name</th>
                            <th data-i18n="editor.text">Text</th>
                            <th data-i18n="editor.actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="commandsBody">
                        <tr>
                            <td colspan="4" style="text-align: center; color: #999;" data-i18n="editor.loadingCommands">Loading commands...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        
        <!-- New Event Section -->
        <section class="section">
            <h2 data-i18n="editor.newEvent">New Event</h2>
            <form id="eventForm">
                <div class="form-inline">
                    <div class="form-group">
                        <label for="eventTime" data-i18n="editor.time">Time (MM:SS):</label>
                        <input type="text" id="eventTime" data-i18n-placeholder="editor.timePlaceholder" placeholder="00:00" pattern="[0-9]{2}:[0-9]{2}" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="eventChannel" data-i18n="editor.channel">Channels (comma-separated, e.g., 1,3,12 or 0 for all):</label>
                        <input type="text" id="eventChannel" data-i18n-placeholder="editor.channelPlaceholder" placeholder="1" required>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="eventCommand" data-i18n="editor.commandSelect">Command Name:</label>
                    <select id="eventCommand" required>
                        <option value="" data-i18n="editor.commandSelectPlaceholder">Select a command...</option>
                    </select>
                </div>
                
                <div class="button-group">
                    <button type="submit" id="addEventBtn" data-i18n="editor.addEvent">Add Event</button>
                </div>
                
                <div id="eventStatus" class="status hidden"></div>
            </form>
        </section>
        
        <!-- Events Table Section -->
        <section class="section">
            <h2 data-i18n="editor.events">Events</h2>
            <div class="button-group">
                <button type="button" id="refreshBtn" class="secondary" data-i18n="editor.refreshEvents">Refresh Events</button>
                <button type="button" id="testBtn" class="secondary" data-i18n="editor.testEvent">Test Event</button>
            </div>
            <div class="button-group" style="margin-top: 15px;">
                <button type="button" id="startBtn" data-i18n="editor.start">Start</button>
                <button type="button" id="stopBtn" class="secondary" data-i18n="editor.stop">Stop</button>
                <button type="button" id="seekBtn" class="secondary" data-i18n="editor.seek">Seek</button>
                <input type="text" id="seekTime" data-i18n-placeholder="editor.timePlaceholder" placeholder="00:00" pattern="[0-9]{2}:[0-9]{2}" style="width: 100px; padding: 10px; background: #3a3a3a; border: 1px solid #4a4a4a; border-radius: 5px; color: #e0e0e0;">
            </div>
            <div style="margin-top: 15px; padding: 10px; background: #3a3a3a; border-radius: 5px; text-align: center;">
                <span style="color: #aaa; margin-right: 10px;" data-i18n="editor.currentTime">Current Time:</span>
                <span id="currentTimeDisplay" style="color: #4a9eff; font-size: 1.2em; font-weight: bold;">00:00</span>
            </div>
            <div id="eventsStatus" class="status hidden"></div>
            <div class="table-wrapper">
                <table id="eventsTable">
                    <thead>
                        <tr>
                            <th class="sortable" data-column="time" data-i18n="editor.time">Time</th>
                            <th class="sortable" data-column="channel" data-i18n="editor.channel">Channel</th>
                            <th data-i18n="editor.commandSelect">Command Name</th>
                            <th data-i18n="editor.actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="eventsBody">
                        <tr>
                            <td colspan="4" style="text-align: center; color: #999;" data-i18n="editor.loadingEvents">Loading events...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>
    
    <!-- Edit Command Modal -->
    <div id="editCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="editor.editCommand">Edit Command</h3>
                <button class="close-btn" onclick="closeEditCommandModal()">&times;</button>
            </div>
            <form id="editCommandForm">
                <input type="hidden" id="editCommandIndex">
                <div class="form-group">
                    <label for="editCommandText" data-i18n="editor.commandText">Command Text:</label>
                    <textarea id="editCommandText" required></textarea>
                </div>
                
                <div class="form-group">
                    <label for="editCommandName" data-i18n="editor.commandName">Command Name (no spaces):</label>
                    <input type="text" id="editCommandName" required pattern="[^\s]+">
                </div>
                
                <div class="button-group">
                    <button type="submit" data-i18n="editor.saveChanges">Save Changes</button>
                    <button type="button" class="secondary" onclick="closeEditCommandModal()" data-i18n="common.cancel">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Edit Event Modal -->
    <div id="editEventModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="editor.editEvent">Edit Event</h3>
                <button class="close-btn" onclick="closeEditModal()">&times;</button>
            </div>
            <form id="editEventForm">
                <input type="hidden" id="editEventIndex">
                <div class="form-inline">
                    <div class="form-group">
                        <label for="editEventTime" data-i18n="editor.time">Time (MM:SS):</label>
                        <input type="text" id="editEventTime" data-i18n-placeholder="editor.timePlaceholder" placeholder="00:00" pattern="[0-9]{2}:[0-9]{2}" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="editEventChannel" data-i18n="editor.channel">Channels (comma-separated):</label>
                        <input type="text" id="editEventChannel" required>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="editEventCommand" data-i18n="editor.commandSelect">Command Name:</label>
                    <select id="editEventCommand" required>
                        <option value="" data-i18n="editor.commandSelectPlaceholder">Select a command...</option>
                    </select>
                </div>
                
                <div class="button-group">
                    <button type="submit" data-i18n="editor.saveChanges">Save Changes</button>
                    <button type="button" class="secondary" onclick="closeEditModal()" data-i18n="common.cancel">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    
    <script>
        // WebSocket connection
        let ws = null;
        let lastGeneratedFile = null;
        
        function connectWebSocket() {
            try {
                ws = new WebSocket('wss://live.uuu.ee:1234');
                
                ws.onopen = () => {
                    console.log('WebSocket connected');
                    showStatus('commandStatus', window.i18n.t('editor.connectedToServer'), 'success');
                };
                
                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    showStatus('commandStatus', window.i18n.t('editor.disconnectedFromServer'), 'error');
                    // Attempt to reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    showStatus('commandStatus', window.i18n.t('editor.connectionError'), 'error');
                };
                
                ws.onmessage = (event) => {
                    console.log('Received message:', event.data);
                    // Handle time messages
                    const message = event.data;
                    if (message.startsWith('time|')) {
                        const timeInSeconds = parseInt(message.split('|')[1]);
                        const minutes = Math.floor(timeInSeconds / 60);
                        const seconds = timeInSeconds % 60;
                        const timeStr = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        document.getElementById('currentTimeDisplay').textContent = timeStr;
                    }
                };
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                showStatus('commandStatus', 'Failed to connect to server: ' + error.message, 'error');
            }
        }
        
        // Initialize WebSocket connection
        connectWebSocket();
        
        // Form submission handler
        document.getElementById('commandForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const text = document.getElementById('commandText').value.trim();
            let commandName = document.getElementById('commandName').value.trim();
            
            // Validate command name (no spaces)
            if (/\s/.test(commandName)) {
                showStatus('commandStatus', window.i18n.t('editor.commandNameNoSpaces'), 'error');
                return;
            }
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                showStatus('commandStatus', window.i18n.t('editor.notConnected'), 'error');
                return;
            }
            
            // Format message: "generateCommand | text | commandName"
            const message = `generateCommand | ${text} | ${commandName}`;
            
            try {
                ws.send(message);
                lastGeneratedFile = commandName;
                showStatus('commandStatus', window.i18n.t('editor.generatingAudio', { name: commandName }), 'info');
                
                // Wait for file generation and update solaris.json
                setTimeout(async () => {
                    await updateCommandInJSON(commandName, text);
                    document.getElementById('listenBtn').disabled = false;
                    showStatus('commandStatus', window.i18n.t('editor.commandSaved', { name: commandName }), 'success');
                    // Refresh events table
                    loadEvents();
                }, 5000);
            } catch (error) {
                showStatus('commandStatus', 'Failed to send command: ' + error.message, 'error');
            }
        });
        
        // Function to update command in solaris.json
        async function updateCommandInJSON(commandName, text) {
            try {
                // Load current solaris.json
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data;
                
                if (response.ok) {
                    data = await response.json();
                } else {
                    // If file doesn't exist, create new structure
                    data = { commands: [], events: [] };
                }
                
                // Check if command already exists
                const existingIndex = data.commands.findIndex(cmd => cmd.name === commandName);
                const fileName = commandName + '.mp3';
                
                if (existingIndex !== -1) {
                    // Replace existing command
                    data.commands[existingIndex] = {
                        name: commandName,
                        fileName: fileName,
                        text: text
                    };
                } else {
                    // Add new command
                    data.commands.push({
                        name: commandName,
                        fileName: fileName,
                        text: text
                    });
                }
                
                // Note: In a real implementation, we would send this to the server to write
                // For now, we'll just log it (the server would need to handle this)
                console.log('Updated solaris.json:', JSON.stringify(data, null, 2));
                
                // Send update to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('updateJSON | ' + JSON.stringify(data));
                }
            } catch (error) {
                console.error('Error updating solaris.json:', error);
            }
        }
        
        // Listen button handler
        document.getElementById('listenBtn').addEventListener('click', () => {
            if (lastGeneratedFile) {
                playAudioFile('audiofiles', lastGeneratedFile);
            }
        });
        
        // Refresh commands button handler
        document.getElementById('refreshCommandsBtn').addEventListener('click', () => {
            loadCommands();
        });
        
        // Refresh button handler
        document.getElementById('refreshBtn').addEventListener('click', () => {
            loadEvents();
        });
        
        document.getElementById('testBtn').addEventListener('click', () => {
           try {
                ws.send("test");
                showStatus('commandStatus', 'Test command sent.');
            } catch (error) {
                showStatus('commandStatus', 'Failed to test send command: ' + error.message, 'error');
            } 
        });
        
        // Start button handler
        document.getElementById('startBtn').addEventListener('click', () => {
            const seekTime = document.getElementById('seekTime').value.trim();
            let message = 'start';
            
            if (seekTime) {
                // Validate time format
                const timePattern = /^[0-9]{2}:[0-9]{2}$/;
                if (timePattern.test(seekTime)) {
                    const [minutes, seconds] = seekTime.split(':').map(Number);
                    const timeInSeconds = minutes * 60 + seconds;
                    message = `start|${timeInSeconds}`;
                }
            }
            
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(message);
                    showStatus('eventsStatus', window.i18n.t('editor.startCommandSent'), 'success');
                } else {
                    showStatus('eventsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventsStatus', 'Failed to send start command: ' + error.message, 'error');
            }
        });
        
        // Stop button handler
        document.getElementById('stopBtn').addEventListener('click', () => {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('stop');
                    showStatus('eventsStatus', window.i18n.t('editor.stopCommandSent'), 'success');
                } else {
                    showStatus('eventsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventsStatus', 'Failed to send stop command: ' + error.message, 'error');
            }
        });
        
        // Seek button handler
        document.getElementById('seekBtn').addEventListener('click', () => {
            const seekTime = document.getElementById('seekTime').value.trim();
            
            if (!seekTime) {
                showStatus('eventsStatus', window.i18n.t('editor.enterTimeToSeek'), 'error');
                return;
            }
            
            // Validate time format
            const timePattern = /^[0-9]{2}:[0-9]{2}$/;
            if (!timePattern.test(seekTime)) {
                showStatus('eventsStatus', window.i18n.t('editor.invalidTimeFormat'), 'error');
                return;
            }
            
            const [minutes, seconds] = seekTime.split(':').map(Number);
            const timeInSeconds = minutes * 60 + seconds;
            
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(`seek|${timeInSeconds}`);
                    showStatus('eventsStatus', window.i18n.t('editor.seekCommandSent', { time: seekTime }), 'success');
                } else {
                    showStatus('eventsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventsStatus', 'Failed to send seek command: ' + error.message, 'error');
            }
        });
        
        // New Event form submission handler
        document.getElementById('eventForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const time = document.getElementById('eventTime').value.trim();
            const channelInput = document.getElementById('eventChannel').value.trim();
            const commandName = document.getElementById('eventCommand').value;
            
            // Validate time format (MM:SS)
            const timePattern = /^[0-9]{2}:[0-9]{2}$/;
            if (!timePattern.test(time)) {
                showStatus('eventStatus', window.i18n.t('editor.invalidTimeFormat'), 'error');
                return;
            }
            
            if (!commandName) {
                showStatus('eventStatus', window.i18n.t('editor.selectCommand'), 'error');
                return;
            }
            
            // Parse channels - split by comma and trim each value
            const channels = channelInput.split(',').map(ch => ch.trim()).filter(ch => ch !== '');
            
            try {
                // Load current data
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data;
                
                if (response.ok) {
                    data = await response.json();
                } else {
                    data = { commands: [], events: [] };
                }
                
                // Convert time to seconds
                const [minutes, seconds] = time.split(':').map(Number);
                const timeInSeconds = minutes * 60 + seconds;
                
                // Add new event with channels as array
                data.events.push({
                    time: timeInSeconds,
                    channels: channels,
                    name: commandName
                });
                
                // Send to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('updateJSON | ' + JSON.stringify(data));
                    showStatus('eventStatus', window.i18n.t('editor.eventAdded'), 'success');
                    
                    // Clear form
                    document.getElementById('eventTime').value = '';
                    document.getElementById('eventChannel').value = '';
                    document.getElementById('eventCommand').value = '';
                    
                    // Refresh events table
                    setTimeout(() => {
                        loadEvents();
                    }, 500);
                } else {
                    showStatus('eventStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventStatus', 'Failed to add event: ' + error.message, 'error');
            }
        });
        
        // Edit Event form submission handler
        document.getElementById('editEventForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const index = parseInt(document.getElementById('editEventIndex').value);
            const time = document.getElementById('editEventTime').value.trim();
            const channelInput = document.getElementById('editEventChannel').value.trim();
            const commandName = document.getElementById('editEventCommand').value;
            
            // Parse channels - split by comma and trim each value
            const channels = channelInput.split(',').map(ch => ch.trim()).filter(ch => ch !== '');
            
            try {
                // Load current data
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data = await response.json();
                
                // Convert time to seconds
                const [minutes, seconds] = time.split(':').map(Number);
                const timeInSeconds = minutes * 60 + seconds;
                
                // Update event with channels as array
                data.events[index] = {
                    time: timeInSeconds,
                    channels: channels,
                    name: commandName
                };
                
                // Send to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('updateJSON | ' + JSON.stringify(data));
                    closeEditModal();
                    showStatus('eventsStatus', window.i18n.t('editor.eventUpdated'), 'success');
                    
                    // Refresh events table
                    setTimeout(() => {
                        loadEvents();
                    }, 500);
                } else {
                    showStatus('eventsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventsStatus', 'Failed to update event: ' + error.message, 'error');
            }
        });
        
        // Edit Command form submission handler
        document.getElementById('editCommandForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const index = parseInt(document.getElementById('editCommandIndex').value);
            const text = document.getElementById('editCommandText').value.trim();
            const commandName = document.getElementById('editCommandName').value.trim();
            
            try {
                // Load current data
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data = await response.json();
                
                // Update command text (name and fileName stay the same)
                data.commands[index] = {
                    name: commandName,
                    fileName: commandName + '.mp3',
                    text: text
                };
                
                // Send to server to regenerate audio
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // First send the generateCommand to update audio
                    ws.send(`generateCommand | ${text} | ${commandName}`);
                    
                    // Then update JSON
                    setTimeout(() => {
                        ws.send('updateJSON | ' + JSON.stringify(data));
                    }, 100);
                    
                    closeEditCommandModal();
                    showStatus('commandsStatus', window.i18n.t('editor.commandUpdated'), 'success');
                    
                    // Refresh commands table
                    setTimeout(() => {
                        loadCommands();
                    }, 1000);
                } else {
                    showStatus('commandsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('commandsStatus', 'Failed to update command: ' + error.message, 'error');
            }
        });
        
        // Global commands array
        let commandsData = [];
        
        // Function to load commands from solaris.json
        async function loadCommands() {
            try {
                showStatus('commandsStatus', window.i18n.t('editor.loadingCommands'), 'info');
                
                const response = await fetch(`../solaris.json?nocache=${Date.now()}`);
                
                if (!response.ok) {
                    throw new Error('Failed to load solaris.json: ' + response.statusText);
                }
                
                const data = await response.json();
                commandsData = data.commands || [];
                const tbody = document.getElementById('commandsBody');
                tbody.innerHTML = '';
                
                if (commandsData.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #999;">' + window.i18n.t('editor.noCommands') + '</td></tr>';
                    showStatus('commandsStatus', window.i18n.t('editor.noCommands'), 'info');
                    return;
                }
                
                // Display each command
                commandsData.forEach((command, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${escapeHtml(command.name)}</td>
                        <td>${escapeHtml(command.fileName)}</td>
                        <td>${escapeHtml(command.text)}</td>
                        <td>
                            <button class="play-btn" onclick="playAudioFile('audiofiles', '${escapeHtml(command.name)}')">${window.i18n.t('common.play')}</button>
                            <button class="edit-btn" onclick="editCommand(${index})">${window.i18n.t('common.edit')}</button>
                            <button class="delete-btn" onclick="deleteCommand(${index})">${window.i18n.t('common.delete')}</button>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
                
                // Populate command dropdowns
                const eventCommandSelect = document.getElementById('eventCommand');
                const editEventCommandSelect = document.getElementById('editEventCommand');
                
                eventCommandSelect.innerHTML = '<option value="">' + window.i18n.t('editor.commandSelectPlaceholder') + '</option>';
                editEventCommandSelect.innerHTML = '<option value="">' + window.i18n.t('editor.commandSelectPlaceholder') + '</option>';
                
                commandsData.forEach(command => {
                    const option1 = document.createElement('option');
                    option1.value = command.name;
                    option1.textContent = command.name;
                    eventCommandSelect.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = command.name;
                    option2.textContent = command.name;
                    editEventCommandSelect.appendChild(option2);
                });
                
                showStatus('commandsStatus', window.i18n.t('editor.loadedCommands', { count: commandsData.length }), 'success');
            } catch (error) {
                console.error('Error loading commands:', error);
                document.getElementById('commandsBody').innerHTML = '<tr><td colspan="4" style="text-align: center; color: #ff8a8a;">' + window.i18n.t('editor.errorLoadingCommands', { error: escapeHtml(error.message) }) + '</td></tr>';
                showStatus('commandsStatus', window.i18n.t('editor.errorLoadingCommands', { error: error.message }), 'error');
            }
        }
        
        // Function to show status messages
        function showStatus(elementId, message, type) {
            const statusEl = document.getElementById(elementId);
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
            statusEl.classList.remove('hidden');
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.classList.add('hidden');
                }, 5000);
            }
        }
        
        // Global events array for sorting
        let eventsData = [];
        let currentSort = { column: null, direction: 'asc' };
        
        // Function to load events from solaris.json
        async function loadEvents() {
            try {
                showStatus('eventsStatus', window.i18n.t('editor.loadingEvents'), 'info');
                
                const response = await fetch(`../solaris.json?nocache=${Date.now()}`);
                
                if (!response.ok) {
                    throw new Error('Failed to load solaris.json: ' + response.statusText);
                }
                
                const data = await response.json();
                eventsData = data.events || [];
                
                displayEvents();
                
                showStatus('eventsStatus', window.i18n.t('editor.loadedEvents', { count: eventsData.length }), 'success');
            } catch (error) {
                console.error('Error loading events:', error);
                document.getElementById('eventsBody').innerHTML = '<tr><td colspan="5" style="text-align: center; color: #ff8a8a;">' + window.i18n.t('editor.errorLoadingEvents', { error: escapeHtml(error.message) }) + '</td></tr>';
                showStatus('eventsStatus', window.i18n.t('editor.errorLoadingEvents', { error: error.message }), 'error');
            }
        }
        
        // Function to display events
        function displayEvents() {
            const tbody = document.getElementById('eventsBody');
            tbody.innerHTML = '';
            
            if (eventsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #999;">' + window.i18n.t('editor.noEvents') + '</td></tr>';
                return;
            }
            
            // Display each event
            eventsData.forEach((event, index) => {
                // Convert time to MM:SS format
                const minutes = Math.floor(event.time / 60);
                const seconds = event.time % 60;
                const timeStr = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                // Handle channels - display as comma-separated if array, otherwise show single channel
                const channelsDisplay = Array.isArray(event.channels) ? event.channels.join(', ') : (event.channel || '');
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(timeStr)}</td>
                    <td>${escapeHtml(channelsDisplay)}</td>
                    <td>${escapeHtml(event.name)}</td>
                    <td>
                        <button class="play-btn" onclick="playAudioFile('audiofiles', '${escapeHtml(event.name)}')">${window.i18n.t('common.play')}</button>
                        <button class="edit-btn" onclick="editEvent(${index})">${window.i18n.t('common.edit')}</button>
                        <button class="delete-btn" onclick="deleteEvent(${index})">${window.i18n.t('common.delete')}</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Function to sort events
        function sortEvents(column) {
            // Update sort direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }
            
            // Sort the events array
            eventsData.sort((a, b) => {
                let valA, valB;
                
                if (column === 'time') {
                    valA = a.time;
                    valB = b.time;
                } else if (column === 'channel') {
                    // Handle both array and single channel
                    valA = Array.isArray(a.channels) ? parseInt(a.channels[0]) : parseInt(a.channel || 0);
                    valB = Array.isArray(b.channels) ? parseInt(b.channels[0]) : parseInt(b.channel || 0);
                }
                
                if (currentSort.direction === 'asc') {
                    return valA - valB;
                } else {
                    return valB - valA;
                }
            });
            
            // Update table headers
            document.querySelectorAll('#eventsTable th.sortable').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.column === column) {
                    th.classList.add('sorted-' + currentSort.direction);
                }
            });
            
            // Re-display events
            displayEvents();
        }
        
        // Add event listeners for sortable columns
        document.querySelectorAll('#eventsTable th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                sortEvents(th.dataset.column);
            });
        });
        
        // Function to edit event
        async function editEvent(index) {
            const event = eventsData[index];
            
            // Convert time to MM:SS format
            const minutes = Math.floor(event.time / 60);
            const seconds = event.time % 60;
            const timeStr = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Convert channels array to comma-separated string
            const channelsStr = Array.isArray(event.channels) ? event.channels.join(', ') : (event.channel || '1');
            
            // Populate form
            document.getElementById('editEventIndex').value = index;
            document.getElementById('editEventTime').value = timeStr;
            document.getElementById('editEventChannel').value = channelsStr;
            document.getElementById('editEventCommand').value = event.name;
            
            // Show modal
            document.getElementById('editEventModal').classList.add('show');
        }
        
        // Function to close edit modal
        function closeEditModal() {
            document.getElementById('editEventModal').classList.remove('show');
        }
        
        // Function to edit command
        async function editCommand(index) {
            const command = commandsData[index];
            
            // Populate form
            document.getElementById('editCommandIndex').value = index;
            document.getElementById('editCommandText').value = command.text;
            document.getElementById('editCommandName').value = command.name;
            
            // Show modal
            document.getElementById('editCommandModal').classList.add('show');
        }
        
        // Function to close edit command modal
        function closeEditCommandModal() {
            document.getElementById('editCommandModal').classList.remove('show');
        }
        
        // Function to delete command
        async function deleteCommand(index) {
            const command = commandsData[index];
            
            if (!confirm(window.i18n.t('editor.deleteCommandConfirm', { name: command.name }))) {
                return;
            }
            
            try {
                // Load current data
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data = await response.json();
                
                // Remove command
                data.commands.splice(index, 1);
                
                // Send to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('updateJSON | ' + JSON.stringify(data));
                    showStatus('commandsStatus', window.i18n.t('editor.commandDeleted'), 'success');
                    
                    // Refresh commands table
                    setTimeout(() => {
                        loadCommands();
                    }, 500);
                } else {
                    showStatus('commandsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('commandsStatus', 'Failed to delete command: ' + error.message, 'error');
            }
        }
        
        // Function to delete event
        async function deleteEvent(index) {
            if (!confirm(window.i18n.t('editor.deleteEventConfirm'))) {
                return;
            }
            
            try {
                // Load current data
                const response = await fetch('../solaris.json?nocache=' + Date.now());
                let data = await response.json();
                
                // Remove event
                data.events.splice(index, 1);
                
                // Send to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('updateJSON | ' + JSON.stringify(data));
                    showStatus('eventsStatus', window.i18n.t('editor.eventDeleted'), 'success');
                    
                    // Refresh events table
                    setTimeout(() => {
                        loadEvents();
                    }, 500);
                } else {
                    showStatus('eventsStatus', window.i18n.t('editor.notConnected'), 'error');
                }
            } catch (error) {
                showStatus('eventsStatus', 'Failed to delete event: ' + error.message, 'error');
            }
        }
        
        // Make functions global for onclick handlers
        window.editEvent = editEvent;
        window.closeEditModal = closeEditModal;
        window.deleteEvent = deleteEvent;
        window.editCommand = editCommand;
        window.closeEditCommandModal = closeEditCommandModal;
        window.deleteCommand = deleteCommand;
        
        // Function to play audio file
        function playAudioFile(directory, fileName) {
            // Remove .mp3 extension if present
            fileName = fileName.replace('.mp3', '');
            
            // Construct path: ../audio/directory/fileName.mp3
            const audioPath = `../audio/${directory}/${fileName}.mp3`;
            
            console.log('Playing audio:', audioPath);
            
            const audio = new Audio(audioPath);
            audio.play().then(() => {
                console.log('Playing audio file:', audioPath);
            }).catch(error => {
                if (error.name === 'AbortError') {
                    console.log('Playback ended normally.');
                } else {
                    console.error('Playback failed:', error);
                    alert('Error playing audio file: ' + audioPath + '\n' + error.message);
                }
            });
        }
        
        // Make playAudioFile global for inline onclick handlers
        window.playAudioFile = playAudioFile;
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize translations and then load data
        document.addEventListener('DOMContentLoaded', async () => {
            await window.i18n.init();
            // Load commands and events after translations are ready
            loadCommands();
            loadEvents();
        });
    </script>
</body>
</html>
